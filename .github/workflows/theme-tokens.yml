name: Chunked Theme Tokens Conversion

on:
  workflow_dispatch:

jobs:
  convert-tokens:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Create theme processor
        run: |
          cat > process-theme.js << 'EOF'
          import fs from 'fs';
          
          async function processTheme() {
            console.log('Starting theme processing...');
            
            try {
              // Read the original theme file
              const themePath = 'src/styles/theme.json';
              console.log(`Reading theme file from ${themePath}...`);
              const themeData = await fs.promises.readFile(themePath, 'utf8');
              console.log(`Theme file read: ${themeData.length} bytes`);
              
              // Parse the theme JSON
              console.log('Parsing theme JSON...');
              const theme = JSON.parse(themeData);
              console.log('Theme parsed successfully');
              
              // Process theme in chunks
              console.log('Starting chunked processing...');
              
              // Create output directory
              const outputDir = 'src/styles/theme-files';
              if (!fs.existsSync(outputDir)) {
                fs.mkdirSync(outputDir, { recursive: true });
              }
              
              // Clean the $themes array
              if (theme.$themes && Array.isArray(theme.$themes)) {
                console.log(`Cleaning $themes array (${theme.$themes.length} items)...`);
                theme.$themes = [];
              }
              
              // Process system tokens directly
              if (theme['System/Default']) {
                console.log('Processing System/Default...');
                processSystemTokens(theme['System/Default'], outputDir);
              } else {
                console.log('No System/Default section found in theme');
              }
              
              // Create base.css
              const baseCSS = `/**
           * Base CSS variables - Common properties across all themes
           * Generated by custom processor
           */
          
          :root {
            /* System font families */
            --System-Font-Families-Standard: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --System-Font-Families-Decorative: "Georgia", "Times New Roman", serif;
            
            /* Other global variables */
            --global-border-radius: 4px;
            --global-transition-duration: 0.2s;
          }\n\n`;
              
              fs.writeFileSync(`${outputDir}/base.css`, baseCSS);
              console.log('Created base.css');
              
              // Process modes in separate chunks
              const modeKeys = Object.keys(theme).filter(key => key.startsWith('Modes/'));
              console.log(`Found ${modeKeys.length} mode keys`);
              
              for (const modeKey of modeKeys) {
                const mode = modeKey.split('/')[1];
                console.log(`Processing mode: ${mode}...`);
                
                try {
                  processModeTokens(mode, theme[modeKey], outputDir);
                } catch (error) {
                  console.error(`Error processing mode ${mode}:`, error);
                }
              }
              
              // Process platforms in separate chunks
              const platformKeys = Object.keys(theme).filter(key => key.startsWith('Platform/'));
              console.log(`Found ${platformKeys.length} platform keys`);
              
              for (const platformKey of platformKeys) {
                const platform = platformKey.split('/')[1];
                console.log(`Processing platform: ${platform}...`);
                
                try {
                  processPlatformTokens(platform, theme[platformKey], outputDir);
                } catch (error) {
                  console.error(`Error processing platform ${platform}:`, error);
                }
              }
              
              console.log('Theme processing completed');
              
            } catch (error) {
              console.error('Error during theme processing:', error);
            }
          }
          
          function processSystemTokens(systemData, outputDir) {
            let css = `:root, ::after, ::before {\n`;
            
            // Minimum Target calculation
            css += ` /* System Variables */\n`;
            css += ` --Min-Target: min(min(var(--Desktop-Target), var(--PlatformTarget)), var(--Cognitive-Target));\n`;
            
            // Process buttons if they exist
            if (systemData.Buttons) {
              const buttons = systemData.Buttons;
              
              // Process button properties
              for (const [propName, propData] of Object.entries(buttons)) {
                if (propData && propData.value !== undefined) {
                  const value = typeof propData.value === 'number' ? `${propData.value}px` : propData.value;
                  css += ` --${propName}: ${value};\n`;
                }
              }
              
              // Add Button-Border if not present
              if (!buttons['Button-Border']) {
                css += ` --Button-Border: 2px;\n`;
              }
            }
            
            // Process breakpoints if they exist
            if (systemData.Breakpoints) {
              for (const [breakpointName, breakpointData] of Object.entries(systemData.Breakpoints)) {
                if (breakpointData && breakpointData.value !== undefined) {
                  css += ` --Breakpoints-${breakpointName.replace(' ', '-')}: ${breakpointData.value}px;\n`;
                }
              }
            }
            
            // Close the CSS block
            css += `}\n`;
            
            // Write the system CSS file
            fs.writeFileSync(`${outputDir}/system.css`, css);
            console.log('Created system.css');
          }
          
          function processModeTokens(modeName, modeData, outputDir) {
            let css = '';
            
            // Process backgrounds if they exist
            if (modeData.Backgrounds) {
              for (const [bgName, bgData] of Object.entries(modeData.Backgrounds)) {
                const bgNameLower = bgName.toLowerCase();
                
                // Create CSS for root background variables
                let rootVars = '';
                
                // Process surface variables
                const surfaceProps = ['Surface', 'Surface-Dim', 'Surface-Bright', 'Surface-Quiet', 
                                     'Surface-Dim-Quiet', 'Surface-Bright-Quiet'];
                
                for (const prop of surfaceProps) {
                  if (bgData[prop] && bgData[prop].value !== undefined) {
                    rootVars += `  --${prop}: ${bgData[prop].value};\n`;
                  }
                }
                
                // Process container variables
                const containerProps = ['Container', 'Container-Low', 'Container-Lowest', 'Container-High', 
                                      'Container-Highest', 'Container-Quiet', 'Container-Low-Quiet', 
                                      'Container-Lowest-Quiet', 'Container-High-Quiet', 'Container-Highest-Quiet'];
                
                for (const prop of containerProps) {
                  if (bgData[prop] && bgData[prop].value !== undefined) {
                    if (prop === 'Container-Quiet') {
                      rootVars += `  --Container-On-Quiet: ${bgData[prop].value};\n`;
                    } else {
                      rootVars += `  --${prop}: ${bgData[prop].value};\n`;
                    }
                  }
                }
                
                // Add dropdown colors
                for (let i = 1; i <= 5; i++) {
                  const key = `Dropdown-Color-${i}`;
                  if (bgData[key] && bgData[key].value !== undefined) {
                    rootVars += `  --${key}: ${bgData[key].value};\n`;
                  }
                }
                
                // Add the background CSS if we have any variables
                if (rootVars) {
                  css += `/* ${modeName} mode specific backgrounds */\n`;
                  css += `[data-mode="${modeName}"] [data-background="${bgNameLower}"] {\n`;
                  css += rootVars;
                  css += '}\n\n';
                }
                
                // Create CSS for surface components
                let surfaceVars = '';
                
                // Map JSON keys to CSS variable names
                const mappings = {
                  'Surface-Icon-Primary': 'Icon-Primary',
                  'Surface-Icon-Secondary': 'Icon-Secondary',
                  'Surface-Icon-Tertiary': 'Icon-Tertiary',
                  'Surface-Icon-Success': 'Icon-Success',
                  'Surface-Icon-Error': 'Icon-Error',
                  'Surface-Icon-Warning': 'Icon-Warning',
                  'Surface-Icon-Info': 'Icon-Info',
                  'Surface-Border': 'Surface-Border',
                  'On-Surface': 'On-Color',
                  'Surface-Button': 'Button',
                  'Surface-On-Button': 'On-Button',
                  'Surface-Button-Half': 'Button-Half',
                  'Surface-Hotlink': 'Hotlink',
                  'Surface-Icon-BG': 'Icon-BG',
                  'Surface-Message-Padding': 'Message-Padding'
                };
                
                // Process mapped variables
                for (const [jsonKey, cssVar] of Object.entries(mappings)) {
                  if (bgData[jsonKey] && bgData[jsonKey].value !== undefined) {
                    surfaceVars += `  --${cssVar}: ${bgData[jsonKey].value};\n`;
                  }
                }
                
                // Process hotlink underline properties
                if (bgData['Surface-Hotlink-Default-Underline'] && 
                    bgData['Surface-Hotlink-Default-Underline'].value !== undefined) {
                  const value = bgData['Surface-Hotlink-Default-Underline'].value.toString() === 'true' ? 'underline' : 'none';
                  surfaceVars += `  --Hotlink-Default-Underline: ${value};\n`;
                }
                
                if (bgData['Surface-Hotlink-Hover-Underline'] && 
                    bgData['Surface-Hotlink-Hover-Underline'].value !== undefined) {
                  const value = bgData['Surface-Hotlink-Hover-Underline'].value.toString() === 'true' ? 'underline' : 'none';
                  surfaceVars += `  --Hotlink-Hover-Underline: ${value};\n`;
                }
                
                // Add the surface CSS if we have any variables
                if (surfaceVars) {
                  css += `[data-mode="${modeName}"] [data-background="${bgNameLower}"] [data-compnent="surface"] {\n`;
                  css += surfaceVars;
                  css += '}\n\n';
                }
              }
            }
            
            // Process charts if they exist
            if (modeData.Charts) {
              for (const [chartType, chartData] of Object.entries(modeData.Charts)) {
                css += `/* ${modeName} mode ${chartType} chart */\n`;
                css += `[data-mode="${modeName}"] [charts="${chartType}"] {\n`;
                
                // Process chart color variables
                for (const [key, valueObj] of Object.entries(chartData)) {
                  if (valueObj.value !== undefined) {
                    css += `  --${key}: ${valueObj.value};\n`;
                  }
                }
                
                css += `}\n\n`;
              }
            }
            
            // Write the mode CSS file
            const modeFilename = `mode-${modeName.toLowerCase()}.css`;
            fs.writeFileSync(`${outputDir}/${modeFilename}`, css);
            console.log(`Created ${modeFilename}`);
          }
          
          function processPlatformTokens(platformName, platformData, outputDir) {
            let css = '';
            
            // Add platform heading
            css += `/* ${platformName} platform specific typography */\n`;
            css += `[data-platform="${platformName}"] {\n`;
            
            // Process Font-Families
            if (platformData['Font-Families']) {
              for (const [fontFamilyName, fontFamily] of Object.entries(platformData['Font-Families'])) {
                if (fontFamily.value !== undefined) {
                  // Convert font family references
                  let value = fontFamily.value;
                  
                  if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
                    if (value.includes('.Standard')) {
                      value = "var(--System-Font-Families-Standard)";
                    } else if (value.includes('.Decorative')) {
                      value = "var(--System-Font-Families-Decorative)";
                    } else {
                      // Generic fallback for other references
                      const refName = value.substring(1, value.length - 1);
                      const parts = refName.split('.');
                      value = `var(--System-${parts.join('-')})`;
                    }
                  }
                  
                  css += `  --Platform-Font-Families-${fontFamilyName}: ${value};\n`;
                }
              }
            }
            
            // Process Default section (contains typography)
            if (platformData['Default']) {
              // Process Body typography
              if (platformData['Default']['Body']) {
                for (const [typeName, typeProps] of Object.entries(platformData['Default']['Body'])) {
                  for (const [propName, propObj] of Object.entries(typeProps)) {
                    let value = propObj.value;
                    
                    // Skip if value is undefined
                    if (value === undefined) {
                      // For Character-Spacing and Paragraph-Spacing that might be missing, 
                      // add a default value of 0
                      if (propName === 'Character-Spacing' || propName === 'Paragraph-Spacing') {
                        value = 0;
                      } else {
                        continue;
                      }
                    }
                    
                    // Format the value based on property type
                    if (propName === 'Font-Family') {
                      if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
                        if (value.includes('.Standard')) {
                          value = "var(--System-Font-Families-Standard)";
                        } else if (value.includes('.Decorative')) {
                          value = "var(--System-Font-Families-Decorative)";
                        } else {
                          // Generic fallback for other references
                          const refName = value.substring(1, value.length - 1);
                          const parts = refName.split('.');
                          value = `var(--System-${parts.join('-')})`;
                        }
                      }
                    } else if (propName.includes('Font-Size') || 
                               propName.includes('Line-Height') || 
                               propName.includes('Paragraph-Spacing')) {
                      // Add 'px' suffix to numeric values that should have units
                      value = `${value}px`;
                    }
                    
                    css += `  --Platform-Body-${typeName}-${propName}: ${value};\n`;
                  }
                }
              }
              
              // Additional typography sections would be processed similarly
            }
            
            // Close the CSS block
            css += '}\n\n';
            
            // Write the platform CSS file
            const platformFilename = `platform-${platformName.toLowerCase()}.css`;
            fs.writeFileSync(`${outputDir}/${platformFilename}`, css);
            console.log(`Created ${platformFilename}`);
          }
          
          // Run the processing
          processTheme();
          EOF
      
      - name: Run theme processor
        run: |
          node process-theme.js
      
      - name: Create theme loader
        run: |
          cat > src/styles/theme-files/theme-loader.js << 'EOF'
          /**
           * Dynamic CSS loader for theme files
           * Auto-generated
           */
          class ThemeLoader {
            constructor() {
              this.loadedStylesheets = new Map();
              this.defaultMode = 'light';
              this.defaultPlatform = this.detectPlatform();
              this.initialized = false;
            }
          
            /**
             * Detect the current platform
             * @returns {string} - Detected platform (desktop, mobile, etc.)
             */
            detectPlatform() {
              // Basic platform detection logic
              const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
              return isMobile ? 'mobile' : 'desktop';
            }
          
            /**
             * Load a CSS file dynamically
             * @param {string} fileName - The CSS file to load
             * @param {string} id - Unique identifier for the stylesheet
             * @returns {Promise} - Promise that resolves when the stylesheet is loaded
             */
            loadStylesheet(fileName, id) {
              return new Promise((resolve, reject) => {
                // If already loaded, resolve immediately
                if (this.loadedStylesheets.has(id)) {
                  resolve();
                  return;
                }
          
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = fileName;
                link.id = id;
          
                link.onload = () => {
                  this.loadedStylesheets.set(id, link);
                  resolve();
                };
          
                link.onerror = () => {
                  reject(new Error(`Failed to load ${fileName}`));
                };
          
                document.head.appendChild(link);
              });
            }
          
            /**
             * Initialize the theme by loading base CSS
             * @returns {Promise} - Promise that resolves when base CSS is loaded
             */
            async initialize() {
              if (this.initialized) {
                return;
              }
          
              try {
                // Load base CSS first
                await this.loadStylesheet('base.css', 'theme-base');
                
                // Load system CSS
                await this.loadStylesheet('system.css', 'theme-system');
                
                this.initialized = true;
              } catch (err) {
                console.error('Error initializing theme:', err);
              }
            }
          
            /**
             * Set the current theme data attributes on the document
             * @param {string} mode - The mode to set
             * @param {string} platform - The platform to set
             */
            setThemeAttributes(mode, platform) {
              document.documentElement.setAttribute('data-mode', mode);
              document.documentElement.setAttribute('data-platform', platform);
            }
          
            /**
             * Load the appropriate CSS files based on settings
             * @param {Object} options - Configuration options
             * @param {string} [options.mode] - The mode to load (light, dark, etc.)
             * @param {string} [options.platform] - The platform to load (desktop, mobile, etc.)
             * @returns {Promise} - Promise that resolves when all stylesheets are loaded
             */
            async loadTheme(options = {}) {
              // Initialize if not already done
              await this.initialize();
              
              const mode = options.mode || this.defaultMode;
              const platform = options.platform || this.defaultPlatform;
          
              const promises = [];
          
              // Load mode CSS
              promises.push(
                this.loadStylesheet(`mode-${mode.toLowerCase()}.css`, `theme-mode-${mode}`)
                  .catch(err => console.warn(`Could not load mode CSS: ${err.message}`))
              );
          
              // Load platform CSS
              promises.push(
                this.loadStylesheet(`platform-${platform.toLowerCase()}.css`, `theme-platform-${platform}`)
                  .catch(err => console.warn(`Could not load platform CSS: ${err.message}`))
              );
          
              // Set data attributes on the document
              this.setThemeAttributes(mode, platform);
          
              return Promise.all(promises);
            }
          }
          
          // Create a global instance
          window.themeLoader = new ThemeLoader();
          
          // Auto-load theme based on default settings
          document.addEventListener('DOMContentLoaded', () => {
            window.themeLoader.loadTheme();
          });
          EOF
      
      - name: Check generated files
        run: |
          echo "Generated CSS files:"
          find src/styles/theme-files -name "*.css" | sort
          
          echo "Total files generated: $(find src/styles/theme-files -type f | wc -l)"
      
      - name: Commit changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          git add src/styles/theme-files/
          git commit -m "Generate theme CSS files with custom processor" || echo "Nothing to commit"
          git push || echo "Nothing to push"