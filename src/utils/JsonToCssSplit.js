/**
 * Fix for JsonToCssSplit.js
 * 
 * This fix moves the cognitive CSS generation code into the proper function scope
 * where jsonContent is defined.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Convert font family references to the proper format
 * @param {string} value - The font family value
 * @returns {string} - The converted value
 */
function convertFontFamilyReference(value) {
  // First check if value is a string
  if (typeof value !== 'string') {
    return value;
  }
  
  // Check if it's a reference (enclosed in braces)
  if (value.startsWith('{') && value.endsWith('}')) {
    if (value.includes('.Standard')) {
      return "var(--System-Font-Families-Standard)";
    } else if (value.includes('.Decorative')) {
      return "var(--System-Font-Families-Decorative)";
    } else {
      // Generic fallback for other references
      const refName = value.substring(1, value.length - 1);
      const parts = refName.split('.');
      return `var(--System-${parts.join('-')})`;
    }
  }
  
  // If not a reference, return as is
  return value;
}

/**
 * Process an object recursively to generate CSS variables
 * @param {Object} obj - The object to process
 * @param {Array} path - The current path in the object (used to build variable names)
 * @param {Array} result - Array to store the generated CSS variables
 */
function processRecursive(obj, path = [], result = []) {
  // Implementation remains unchanged
  // ...

  return result;
}

/**
 * Extract cognitive typography variables
 * @param {Object} cognitiveContent - The cognitive content object
 * @param {String} cognitiveName - The cognitive name
 * @returns {Array} - Array of CSS variable declarations
 */
function extractCognitiveVariables(cognitiveContent, cognitiveName) {
  const variables = [];
  
  // Implementation remains unchanged
  // ...
  
  return variables;
}

/**
 * Convert the given JSON content to multiple CSS files with a base file
 * @param {Object} jsonContent - The parsed JSON content
 * @param {string} outputDir - The directory to save output files
 * @returns {Object} - Object with information about generated files
 */
async function convertToCssFiles(jsonContent, outputDir) {
  console.log(`Attempting to create output directory: ${outputDir}`);
  
  const results = {
    base: null,
    modes: [],
    platforms: [],
    cognitive: [],
    sizingSpacing: [],
    surfaceContainers: null,
    system: null
  };
  
  // Create the output directory if it doesn't exist
  if (!fs.existsSync(outputDir)) {
    try {
      fs.mkdirSync(outputDir, { recursive: true });
      console.log(`Successfully created output directory: ${outputDir}`);
    } catch (mkdirError) {
      console.error(`Error creating output directory: ${mkdirError}`);
      throw mkdirError;
    }
  }
  
  // Extract common variables for the base CSS file
  let baseCSS = `/**
 * Base CSS variables - Common properties across all themes
 * Generated by JsonToCss
 */

:root {
  /* System font families */
  --System-Font-Families-Standard: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  --System-Font-Families-Decorative: "Georgia", "Times New Roman", serif;
  
  /* Other global variables */
  --global-border-radius: 4px;
  --global-transition-duration: 0.2s;
}\n\n`;
  
  // Save base CSS file
  const baseFilename = 'base.css';
  const baseFilePath = path.join(outputDir, baseFilename);
  await fs.promises.writeFile(baseFilePath, baseCSS, 'utf8')
    .then(() => console.log(`Successfully wrote ${baseFilename}`))
    .catch(err => console.error(`Error writing ${baseFilename}:`, err));

  results.base = {
    file: baseFilename,
    path: baseFilePath
  };
  
  // Process cognitive styles if they exist - MOVED THIS CODE INTO THE FUNCTION
  if (jsonContent['Cognitive/None']) {
    const cognitiveCss = `[data-platform] {\n${
      extractCognitiveVariables(jsonContent['Cognitive/None']).join('')
    }}\n`;
    
    const cognitiveFilename = 'cognitive.css';
    const cognitiveFilePath = path.join(outputDir, cognitiveFilename);
    
    await fs.promises.writeFile(cognitiveFilePath, cognitiveCss, 'utf8');
    results.cognitive = {
      file: cognitiveFilename,
      path: cognitiveFilePath
    };
  }
  
  // Process system tokens
  if (jsonContent['System/Default']) {
    const systemCSS = convertSystemToCss(jsonContent);
    const systemFilename = 'system.css';
    const systemFilePath = path.join(outputDir, systemFilename);
    
    await fs.promises.writeFile(systemFilePath, systemCSS, 'utf8');
    results.system = {
      file: systemFilename,
      path: systemFilePath
    };
  }
  
  // Rest of the implementation...
  // ...
  
  return results;
}

/**
 * Main function to convert a JSON file to multiple CSS files
 * @param {string} inputPath - Path to the input JSON file
 * @param {string} outputDir - Path for the output directory
 */
async function convertJsonFileToCssFiles(inputPath, outputDir) {
  try {
    // Read the JSON file
    const data = await fs.promises.readFile(inputPath, 'utf8');
    const jsonContent = JSON.parse(data);
    
    // Transform to multiple CSS files
    const results = await convertToCssFiles(jsonContent, outputDir);
    
    console.log(`Successfully generated CSS files in ${outputDir}`);
    console.log(`- base.css (common styles)`);
    
    if (results.system) {
      console.log(`- system.css (system tokens)`);
    }
    
    if (results.surfaceContainers) {
      console.log(`- surface-containers.css (surface containers)`);
    }
    
    if (results.sizingSpacing) {
      console.log(`- sizing-spacing.css (sizing and spacing)`);
    }
    
    console.log(`- ${results.modes.length} mode files`);
    console.log(`- ${results.platforms.length} platform files`);
    
    return results;
  } catch (error) {
    console.error('Error converting JSON to CSS files:', error);
    process.exit(1);
  }
}

// Handle command line arguments
if (process.argv[1] === fileURLToPath(import.meta.url)) {
  if (process.argv.length < 4) {
    console.error('Usage: node JsonToCssSplit.js <inputJsonPath> <outputDirectory>');
    process.exit(1);
  }
  
  const inputPath = process.argv[2];
  const outputDir = process.argv[3];
  
  convertJsonFileToCssFiles(inputPath, outputDir)
    .then(results => {
      console.log('Conversion completed successfully!');
    })
    .catch(err => {
      console.error('Error:', err);
      process.exit(1);
    });
}

/**
 * Convert System tokens to CSS custom properties
 * @param {Object} jsonContent - The parsed JSON content
 * @returns {string} - Generated CSS for system tokens
 */
function convertSystemToCss(jsonContent) {
  const systemDefaults = jsonContent['System/Default'];
  
  // Start building CSS
  let css = `:root, ::after, ::before {\n`;
  
  // Minimum Target calculation
  css += ` /* System Variables */\n`;
  css += ` --Min-Target: min(min(var(--Desktop-Target), var(--PlatformTarget)), var(--Cognitive-Target));\n`;
  
  // Buttons
  if (systemDefaults && systemDefaults.Buttons) {
    const buttons = systemDefaults.Buttons;
    const buttonProps = [
      ['Button-Height', buttons['Button-Height']],
      ['Button-Minimum-Width', buttons['Button-Minimum-Width']],
      ['Button-Border-Radius', buttons['Button-Border-Radius']],
      ['Button-Focus-Radius', buttons['Button-Focus-Radius']],
      ['Button-Horizontal-Padding', buttons['Button-Horizontal-Padding']],
      ['Button-Horizontal-Padding-With-Icon', buttons['Button-Horizontal-Padding-With-Icon']],
      ['Button-Small-Height', buttons['Button-Small-Height']],
      ['Button-Small-Horizontal-Padding', buttons['Button-Small-Horizontal-Padding']],
      ['Button-Small-Horizontal-Padding-With-Icon', buttons['Button-Small-Horizontal-Padding-With-Icon']],
      ['Button-Border', {value: 2, type: 'number'}]
    ];
    
    buttonProps.forEach(([prop, propObj]) => {
      if (propObj) {
        const value = typeof propObj.value === 'string' && propObj.value.startsWith('{') 
          ? propObj.value.replace(/[{}]/g, '').replace(/\./g, '-') 
          : propObj.value;
        
        css += ` --${prop}: ${typeof value === 'number' ? `${value}px` : `var(--${value})`};\n`;
      }
    });
  }
  
  // Breakpoints
  if (systemDefaults && systemDefaults.Breakpoints) {
    const breakpointProps = ['Small', 'Medium', 'Large', 'Extra-Large', 'Extra-Small', 'Extra-Extra-Large'];
    
    breakpointProps.forEach(prop => {
      if (systemDefaults.Breakpoints[prop]) {
        css += ` --Breakpoints-${prop.replace(' ', '-')}: ${systemDefaults.Breakpoints[prop].value}px;\n`;
      }
    });
  }
  
  // Close the CSS block
  css += `}\n`;
  
  return css;
}

// Export all functions
export { 
  convertFontFamilyReference,
  convertSystemToCss,
  extractModeVariables,
  extractChartVariables,
  extractPlatformVariables,
  processParagraphSpacing,
  processModeTarget,
  processSurfaceContainers,
  processSizingSpacing,
  convertToCssFiles,
  processBackgrounds,
  convertJsonFileToCssFiles
};
